\newpage
## Script, P2SH и Miniscript {#sec:miniscript}

\EpisodeQR{4}

В этой главе мы поговорим о Miniscript и о том, как он значительно упрощает использование Bitcoin Script. Мы расскажем, как работает Script, как с его помощью можно делать более сложные и даже абсурдные вещи, и как появился Miniscript, чтобы сделать транзакции менее сложными и более безопасными. Кроме того, в главе будет рассказано о том, какова политика этого языка, и как она может упростить создание сценариев.

### Ограничения

Скрипты — это о том, как блокчейн Биткоина ограничивает возможности траты некой конкретной монеты: когда вы хотите получить биткоин, вы сообщаете человеку, отправляющему его, какие правила применяются к транзакции. Например, без каких-либо ограничений любой может посмотреть, что находится в вашем кошельке. Обычно вы добавляете ограничение, что только вы можете тратить эти монеты. Или, если быть более точным, «эти монеты могут быть потрачены только в том случае, если транзакция включает в себя подпись, сделанную с помощью определенного открытого ключа, а именно моего ключа».

Таким образом, вы должны сообщить человеку, отправляющему биткоины, либо ваш открытый ключ, либо его хэш. Для этого и нужны адреса, как мы объясняли в главе @sec:address. Затем отправитель должен поместить их в блокчейн с пометкой о том, что только владелец этого открытого ключа может тратить биткоины.

Однако, хотя это, безусловно, самый распространенный тип ограничения, существует множество других типов ограничений, и вы даже можете указать несколько различных вариантов для того, кто тратит, например: «Я могу потратить это, но для этого моей маме также нужно подписать транзакцию. Но через два года, может быть, я смогу подписать ее и в одиночку». В таком сценарии, если вы хотите потратить деньги, вам нужно указать, какой вариант вы используете, и выполнить только определенные критерии для этого варианта.

### Как работает Script

Script^[<https://en.bitcoin.it/wiki/Script>] — это язык, основанный на стеке, поэтому думайте о нем как о стопке тарелок. На стопку можно ставить тарелки, можно снимать верхнюю тарелку, но нельзя манипулировать тарелками посередине.

Стек работает иначе, чем обычная память, где вы можете читать и записывать произвольные адреса (например, жесткий диск или ОЗУ — память с произвольным доступом). Стек легче реализовать и представить. ^ [Напротив, смарт-контракты Ethereum имеют стек, а также обычную память и даже долгосрочное хранилище. Как следствие, разработчикам гораздо труднее представлять себе его поведение. <https://dlt-repo.net/storage-vs-memory-vs-stack-in-solidity-ethereum/>].

Наиболее часто используемый (до SegWit, см. главу @sec:segwit) биткоин-скрипт выглядит следующим образом:

- `OP_DUP` (как в дубликате)
- `OP_HASH160` (который дважды берет хэш SHA-256, а затем хэш RIPEMD-160)
- `pubKeyHash` (хэш приватного ключа)
- `OP_EQUAL_VERIFY`
- `OP_CHECKSIG`

Значение для `pubKeyHash` генерируется кошельком получателя путем выполнения двойного хэширования SHA-256, за которым следует RIPEMD-160, и результат вставляется в приведенный выше скрипт. Как объяснялось в главе @sec:address, _биткоин-адрес_ содержит только `pubKeyHash`; остальное подразумевается. На самом деле именно кошелек отправителя генерирует полный скрипт перед его публикацией в блокчейне.

В блокчейне этот скрипт заканчивается выходом транзакции. Выход транзакции, то есть монета, состоит из этого скрипта, которым она заблокирована (`scriptPubKey`) и суммы. Теперь, если вы хотите потратить монеты, вы создаете вход транзакции, который дает указание блокчейну добавить определенные вещи в стек _перед_ выполнением вышеприведенного скрипта.

Интерпретатор Биткоина увидит, что вы поместили в стек, и начнет выполнять программу, начиная с выхода. В этом случае то, что вы помещаете в стек — это ваша подпись и ваш открытый ключ, потому что исходный скрипт не имел вашего открытого ключа; у него был только его хэш.

Продолжая вышеприведенный пример, мы начнем со стопки, состоящей из двух тарелок. Тарелка внизу это ваша подпись, а сверху тарелка с вашим открытым ключом, а дальше скрипт говорит `OP_DUP`. Это производит операцию pop, т. е. скрипт берет верхний элемент из стека — верхнюю тарелку, которая является открытым ключом — и дублирует его. Затем оригинал и дубликат помещаются в стек. Итак, теперь у вас две тарелки с публичным ключом наверху стека, а ваша подпись по-прежнему внизу.
  
Следующая инструкция — «OP_HASH160». Она извлекает один из этих двух дубликатов открытых ключей из стека и хэширует его, а затем помещает этот хэш в стек.

Подпись все еще внизу, потом публичный ключ, а потом хэш публичного ключа (три тарелки).

Следующая операция — «pubKeyHash», которая помещает хэш вашего открытого ключа в стек. Итак, теперь хэш вашего открытого ключа дважды повторен на вершине стека.

Операция OP_EQUAL_VERIFY извлекает оба этих хэша из стека и проверяет, совпадают ли они.

В стеке остается ваша подпись и ваш открытый ключ, поэтому `OP_CHECKSIG` проверяет подпись с помощью вашего открытого ключа, после чего стек оказывается пустым.

Именно так, в двух словах, работает программа на языке Script, и в ходе ее выполнения вы можете делать сколь угодно сложные вещи.

### Хэш скрипта и P2SH

Вообще, всякий раз, когда вы хотите получить от кого-то монеты, вы должны точно указать, какой скрипт использовать. В приведенном выше примере все, что нужно — это предоставить хэш открытого ключа в стандартном формате адреса, и кошелек отправителя создаст корректный скрипт.

Но в более сложном примере, приведенном ранее, с альтернативными условиями, такими как наличие подписи родителя через несколько лет, сообщать об этом становится неудобно. Даже если бы для подобного существовал стандарт адреса, ради учета всех возможных ограничений это был бы чрезвычайно длинный адрес.

К счастью, есть альтернатива передаче контрагенту (отправителю) полного скрипта — вы можете передать ему хэш скрипта, который всегда имеет одинаковую длину, причем точно такую же длину, что и обычный адрес.

В 2012 году был введен стандарт Pay-to-Script-Hash (P2SH).^[<https://en.bitcoin.it/wiki/BIP_0016>] Эти виды транзакций позволяют вам использовать в качестве адреса отправления хэш скрипта (такой адрес должен начинаться с 3), вместо отправки на хэш открытого ключа (такой адрес начинался с 1).

Находящийся на другом конце должен скопипастить этот адрес в свой биткоин-кошелек и отправить на него деньги. Теперь, когда вы хотите потратить эти деньги, вам нужно открыть блокчейну фактический скрипт, который ваш кошелек далее автоматически обработает. Поскольку все, что вам для этого нужно, это хэш, человеку, который отправляет вам деньги, не нужно заботиться о том, что на самом деле скрывается за этим хэшем. Только когда вы тратите монеты, вам нужно раскрыть ограничения. С точки зрения приватности это намного лучше, чем сразу вставлять скрипт в блокчейн. В главе @sec:taproot_basics объясняется, как Taproot идет еще дальше.

Как и в случае с обычными адресами P2PKH, то, что вы сообщаете отправителю - это просто хэш скрипта. Прежде чем кошелек отправителя поместит его в блокчейн, он добавляет в начало OP_HASH160 и в конец OP_EQUAL. Так что это, по сути, скрипт внутри скрипта. Внешний скрипт, который кошелек помещает в блокчейн, сообщает блокчейну, что существует внутренний скрипт, который должен быть раскрыт _и исполнен_ получателем, и тогда с него можно тратить деньги.

Это последнее требование на самом деле не следует из скрипта в блокчейне, для которого требуется только совпадение хэша скрипта. Вот почему новый тип адреса P2SH появился с софт-форком, чтобы гарантировать, что, когда такой скрипт находится внутри скрипта, он также выполняется. Обычно это означает, что плательщик помещает в стек не только скрипт, но и ингредиенты, необходимые для выполнения скрипта, такие как подпись.

### Реально абсурдные вещи

Script — это язык программирования, который был представлен в Биткоине, хотя он напоминает ранее существовавший язык, известный как Forth. Также он, похоже, исправлялся на ходу под влиянием запоздалых соображений. Фактически, многие операции, которые были частью языка, потребовалось удалить почти сразу, потому что они обеспечивали множество способов, которыми можно было просто сломать узел сети, или сделать другие плохие вещи.^[
К сожалению, в случае с Биткоином нельзя просто начать с черновика языка, а позже довычистить его. Но это стало ясно только тогда, когда разработчики осознали, что единственный безопасный способ обновить Биткоин — это тщательно продуманные софт-форки. Каждое изменение должно быть обратно совместимым и не ломать уже существующие скрипты. Но разработчики не всегда могут знать назначение уже существующих скриптов, и, что еще хуже, как объяснялось выше, большинство скриптов хэшируются, поэтому они могут содержать что угодно.
<!-- Двойной символ \ необходим для разделения абзацев в сноске. Без него все, кроме первого абзаца, полностью исчезает. -->
\
\
В результате попытки убедиться, что обновления языка Script не делают ничего плохого или непредсказуемого, оказывались полным кошмаром. Если выяснялось, что на существующие узлы могло быть оказано негативное влияние, то есть они падали из-за какого-то непонятного скрипта, разработчикам приходилось очень тщательно обходить эту трудность; они должны были решать проблему, не делая случайно монеты непригодными для использования и не добавляя новых ошибок, в том числе в любом потенциально неизвестном (хэшированном) скрипте.
\
\
Что еще хуже, поскольку Биткоин — это живая система, и пользователей нельзя заставить обновляться всем одновременно, в идеале исправление не должно подсказывать злоумышленнику, в чем проблема. Но в то же время Биткоин это открытая и прозрачная система, в которую нельзя вносить изменения без публичного обоснования. Это делает ответственное раскрытие информации (<https://github.com/bitcoin/bitcoin/blob/master/SECURITY.md>) очень сложным. Так что действительно в первую очередь лучше сделать все возможное, чтобы вовсе избежать таких проблем.
]

Язык Script достаточно разнообразен, чтобы допускать странные вещи. Если вы просто хотите, чтобы кто-то отправил вам деньги, вам нужен лишь вышеописанный очень простой стандартный сценарий: `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`.

Но допустим, вы сотрудничаете и хотите сделать мультиподпись. Чтобы потратить монеты, необходимо предоставить две подписи, а не одну. Теперь вы можете просто использовать `OP_CHECKMULTISIG`, но, допустим, его еще не существует. Вместо этого вы можете взять вышеприведенный скрипт для одной подписи и более или менее продублировать его, например: `<KEY_A> OP_CHECKSIGVERIFY <KEY_B> OP_CHECKSIG`. В этом примере у вас ключ B, второй подлежащий проверке ключ (мы также не беспокоимся о хэшировании открытых ключей).

По сути, если вы начинаете с этих двух открытых ключей и двух подписей в стеке и запускаете скрипт по одной инструкции за раз, то, если A и B поместят в стек действительные подписи, все будет хорошо. Это будет такая мультиподпись для нищих.

Однако злоумышленник может вставить код с именем `OP_RETURN` в середине скрипта: `<KEY_A> OP_CHECKSIGVERIFY OP_RETURN <KEY_B> OP_CHECKSIG`.

Этот код `OP_RETURN` указывает блокчейну прекратить выполнение программы — другими словами, пропустить проверку подписи B - вашей подписи.

Если вы наивно смотрели на этот скрипт, то могли подумать, что ваша подпись проверяется в конце, и поэтому остальная часть скрипта не актуальна. Если бы у вас был бдительный электронный юрист (т. е. человек или компьютерная программа, которые проводят комплексную проверку транзакций), который должным образом проверил бы, выполняет ли этот «умный контракт» то, о чем он говорит, он мог бы сказать: «Осторожно, тут не проверяют действительность вашей подписи». Этот гипотетический электронный юрист должен увидеть написанное мелким шрифтом OP_RETURN, и предупредить вас. Но проблема в том, что существует бесчисленное множество способов, при которых скрипты могут сработать некорректно, поэтому нам нужен стандартизированный способ работы с подобными скриптами.

В интервью Bitcoin Magazine ^[<https://bitcoinmagazine.com/technical/miniscript-how-blockstream-engineers-are-making-bitcoin-programming-easyer>] Эндрю Поэлстра сказал: «В биткоин-скрипте есть коды операций, которые делают действительно абсурдные вещи, например, интерпретируют подпись как значение true/false, разветвляются по этому значению; преобразовают это логическое значение в число, а затем индексируют стек и сортируют его по этому числу. И конкретные правила того, как скрипт это делает, просто сумасшедшие».

Эта цитата иллюстрирует сложность потенциальных способов возни с языком Script.

Возвращаясь к аналогии со стопкой тарелок, представьте, что вы берете молоток и разбиваете одну, а затем прячете две где-то в стопке и красите одну в красный цвет, и после этого скрипт все еще работает, если вы проделаете шаги должным образом. Это совершенно абсурдно.

Это было долгое рассуждение о проблемах Script^[Если вам этого мало, посмотрите двухчасовую презентацию Эндрю Поэлстры на London Bitcoin Devs, где он продолжает и продолжает рассказывать о проблемах в Script: <https://www.youtube.com/watch?v=_v1lECxNDiM>], а если вкратце, то: легко сделать ошибки или скрыть ошибки и создать всевозможные сложные механизмы, которые люди могут заметить или не заметить. И тогда ваши деньги уходят туда, куда вы не хотите. Мы уже видели это в других проектах, например, во взломе Ethereum DAO и последующем хард-форке^[<https://ogucluturk.medium.com/the-dao-hack-explained-unfortunate-take-off-of-smart-contracts-2bd8c8db3562>] насколько плохи могут оказаться дела, если у вас очень сложный язык, который делает то, чего вы совсем не ожидаете. Но Биткоин увернулся от многих пуль в первые дни, и, несмотря на его относительную простоту,^[<https://blockstream.com/2018/11/28/en-simplicity-github/>] он по-прежнему требует бдительности.

### Enter Miniscript

Miniscript^[<https://medium.com/blockstream/miniscript-bitcoin-scripting-3aeff3853620>] — это проект, разработанный несколькими инженерами Blockstream: Питером Вуилле, Эндрю Поэлстрой и Санкетом Канжалкаром. Это «язык для написания (подмножества) биткоин-скриптов в структурированном виде, обеспечивающем анализ, композицию, подписи и многое другое». Вы можете увидеть примеры и попробовать разобраться с ним сами на <https://bitcoin.sipa.be/miniscript>.

Miniscript состоит из нескольких десятков фрагментов на Script, каждый из которых представляет собой последовательность кодов операций. Эти фрагменты можно комбинировать. Если отдельные коды операций на Script подобны алфавиту, то фрагменты на Miniscript подобны словам. Создавая скрипт, который использует только эти слова, а не любую комбинацию букв алфавита, вы теряете некоторые возможности Script, но получаете определенные гарантии безопасности и правильного поведения скриптов.

Простым примером кода на Miniscript является `pkh(A)`, который состоит только из одного фрагмента. Это эквивалент стандартного сценария P2PKH, проанализированного выше (`OP_DUP OP_HASH160 <pubKeyHashA> OP_EQUALVERIFY OP_CHECKSIG`). А приведенная выше мультиподпись для нищих требует уже нескольких фрагментов на Miniscript: `and_v(v:pk(pubKeyA),pk(pubKeyB))`.

Miniscript следит за тем, чтобы в коде не было всяких приколов мелким шрифтом. Он удаляет некоторые ножные пистолеты^[Небезопасные фрагменты кода, из-за которого пользователи стреляют себе в ногу. Ранний разработчик Биткоина Грегори Максвелл использовал этот термин еще в 2012 году, см., например, <https://github.com/bitcoin/bitcoin/pull/1889#issuecomment-9638527>, но, возможно, он еще старше], но помимо этого он также позволяет безопасно делать очень классные вещи. В частности, он вводит такие выражения, как `И`. Таким образом, вы можете сказать, что условие «А» должно быть истинным, и условие «Б» должно быть истинным. Аналогично, вы можете делать и что-то вроде «ИЛИ». И все, что находится внутри «И» или внутри «ИЛИ», может быть сколь угодно сложным.

Вместо этого в Bitcoin Script у вас есть операторы `if` и `else`, но если вы не будете осторожны, эти операторы `if` и `else` будут делать не то, что вы предполагаете, потому что за этими выражениями скрывается сложная начинка.

Между тем шаблоны Miniscript гарантируют, что вы делаете только то, что и предполагаете делать. Допустим, вы — компания и предлагаете полукастодиальное решение для кошелька, в котором у вас есть один из ключей пользователя, а у самого пользователя — два ключа. У вас нет большинства ключей, но, скажем, есть пятилетний тайм-аут, после которого у вас появляется контроль - на случай, если пользователь умрет или произойдет что-то подобное.

У вас получается нечто похожее на настройку мультиподписи. Обычно, когда вы настраиваете мультиподпись, каждый дает свой открытый ключ^[Обычно каждый предоставляет не один открытый ключ, а целую серию открытых ключей, например, используя расширенный открытый ключ (так называемый xpub)], и вы создаете простой скрипт, который требует три ключа, подписанные тремя людьми. Но проблема в том, что вы крупный бизнес, предлагающий услуги, у вас очень сложная внутренняя бухгалтерия, и вы, возможно, захотите иметь пять разных подписей от конкретных людей, согласно правилам различной сложности.

То есть вам нужно пройти сложную процедуру согласования, а то, что получается на выходе, должно считаться одним ключом.

Здесь есть проблема: как клиент узнает, что скрипт в порядке? Ему придется нанять собственного электронного юриста, чтобы проверить, нет ли в скрипте каких-то мелких уловок.

Miniscript позволяет это проверить. Некий футуристический кошелек может показать вам небольшую круговую диаграмму, говоря: «Вы — это один фрагмент диаграммы, и есть еще один фрагмент, который действительно сложен, но вам не нужно об этом беспокоиться. Он не собирается делать ничего подлого».

### Policy Language

A policy language is a way to express your intentions. It’s easier than writing a Miniscript directly, let alone writing Bitcoin Script directly. A compiler then does the hard work.

Our earlier example of a poor man’s multisig was actually found this way. Starting with a policy `and(pk(KEY_A),pk(KEY_B))`, the compiler produced `and_v(v:pk(KEY_A),pk(KEY_B))`, which is equivalent to the script `<KEY_A> OP_CHECKSIGVERIFY <KEY_B> OP_CHECKSIG`. It turns out this actually produces a lower fee transaction than `<KEY_A> <KEY_B> 2 OP_CHECKMULTISIG`. This is the kind of optimization a human might overlook, which is what compilers are good for.

Basically, you write a policy language, which is like a higher-level programming language, which the compiler turns into low level op codes. These are instructions like the ones we described above for popping things off the stack and duplicating them. Miniscript also lives at that very low level, even if it’s slightly more readable and a lot safer. It’s the compiler’s job to take a high level language like Policy Language and turn into the most efficient low-level code.

In the case of multisig, you might say, “I just want two out of two signatures. I don’t care how you do that.” The compiler knows there are multiple ways to execute the intention. And then, the question is, which of them will be picked? The answer to that depends on the transaction weight and the fees that might be involved.

However, you can also tell the compiler, “OK, I think most of the time it’s condition A, but only 10 percent of the time it’s condition B.” The compiler would then calculate the fee for condition A, multiply by 9, add the fee for condition B and divide the total by 10 in order to get the average expected fee. It can optimize for typical use cases, worst case scenarios, all these things, and it then spits out a Miniscript which can then be transpiled to Bitcoin Script.^[The technical term for going from Miniscript to Script — or for transforming source code from any language into another similar one — is transpiling, which can basically be done in two directions. So you can go from Miniscript to Script, or from Script to Miniscript, but you can’t trivially go back to a policy language. However, using automated analysis tools, you can often still figure out what policy language was used to produce a given piece of Miniscript.]

With Taproot (see chapter @sec:taproot_basics), rather than splitting different conditions using _and_ / _or_, they can be split into a Merkle tree of scripts. You don’t have to worry about how to build the Merkle tree, as the compiler takes care of that. In principle, each leaf can also contain _and_ / _or_ statements. Does it make sense to do that? Or is it better to stick to one condition per leaf? Who knows? A future Miniscript compiler can just try all permutations and decide what’s optimal.

### Limitations

All this said, there are some limitations when you’re using policy language or Miniscript in general.

To ensure Miniscript and its corresponding Bitcoin Script can be safely reasoned about, it does not provide access to the full power of script. Sometimes, however, doing things safely results in a script that’s unacceptably long and expensive to execute. In that case, a human may be able to construct a better solution. In regard to the example Poelstra mentioned of how transactions for the Lightning network deal with time locks, hashes, or nonces, there are some optimizations. As he put it: “Oh, you do some weird switching of the stack and you interpret things, not the way they were.” You put a public key on it, but you interpret it as a number — those kind of weird tricks.

Those might be very hard to reason about, and a human might be able to do it, but the Miniscript compiler wouldn’t, which means the compiler would end up with potentially longer Lightning scripts. Perhaps one day Miniscript can be expanded so it can also find these shortcuts. But the Miniscript developers have to be careful, because they really want to make sure there’s nothing in Miniscript that brings back the scary properties of the underlying language.

Another limitation is policy language is just one of several tools needed to make very complicated multisig wallets a practical reality. There are still questions left to answer, such as: How exactly do you do this setup? What are you emailing to each other? Are you emailing your keys or are you emailing something a little bit more abstract that you agree on first and then you exchange keys? These are practical things that aren’t solved inside a Miniscript.

At the time of writing, integrating Miniscript into the Bitcoin Core wallet is still very much a work in progress.^[<https://github.com/bitcoin/bitcoin/pull/24149>]
